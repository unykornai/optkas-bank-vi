"""
Legal Opinion Generator
========================
Generates institutional-grade legal opinion reports covering:

  A. Regulatory Exposure Summary
  B. Authority Opinion
  C. Enforceability Summary
  D. Jurisdiction Conflict Analysis
  E. Recommended Escrow Structure

Banks and institutional counterparties require opinions, not just agreements.
This module produces the analytical layer that precedes document generation.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import date, datetime
from typing import Any

from engine.schema_loader import (
    get_jurisdiction_full_name,
    load_jurisdiction_rules,
    load_master_rules,
    load_transaction_type,
)
from engine.validator import ComplianceValidator
from engine.red_flags import RedFlagDetector
from engine.conflict_matrix import ConflictMatrix
from engine.evidence_validator import EvidenceValidator
from engine._icons import GRADE_ICONS, ICON_CHECK, ICON_CROSS
from engine.policy_engine import PolicyEngine


# ---------------------------------------------------------------------------
# Models
# ---------------------------------------------------------------------------

@dataclass
class OpinionSection:
    title: str
    grade: str  # CLEAR, QUALIFIED, ADVERSE, UNABLE_TO_OPINE
    body: list[str] = field(default_factory=list)
    conditions: list[str] = field(default_factory=list)

    @property
    def icon(self) -> str:
        return GRADE_ICONS.get(self.grade, GRADE_ICONS["UNABLE_TO_OPINE"])


@dataclass
class LegalOpinion:
    entity_name: str
    counterparty_name: str
    transaction_type: str
    generated_at: str
    sections: list[OpinionSection] = field(default_factory=list)
    overall_grade: str = "UNABLE_TO_OPINE"
    signature_ready: bool = False
    signature_blocked_reason: str = ""

    def render(self) -> str:
        lines = [
            "=" * 70,
            "LEGAL OPINION — CONFIDENTIAL",
            "=" * 70,
            "",
            f"Date:            {self.generated_at}",
            f"Re:              {self.transaction_type}",
            f"Party A:         {self.entity_name}",
            f"Party B:         {self.counterparty_name}",
            f"Overall Grade:   {self.overall_grade}",
            "",
            "DISCLAIMER: This opinion is generated by an automated compliance",
            "engine. It does not constitute legal advice. Independent counsel",
            "review is required before reliance.",
            "",
            "-" * 70,
        ]

        for i, section in enumerate(self.sections, 1):
            lines.append("")
            lines.append(f"SECTION {i}: {section.title}")
            lines.append(f"Grade: {section.icon} {section.grade}")
            lines.append("-" * 40)
            for line in section.body:
                lines.append(f"  {line}")
            if section.conditions:
                lines.append("")
                lines.append("  CONDITIONS / QUALIFICATIONS:")
                for cond in section.conditions:
                    lines.append(f"    • {cond}")
            lines.append("")

        lines.append("=" * 70)
        lines.append(f"END OF OPINION -- {self.generated_at}")
        if self.signature_blocked_reason:
            lines.append("")
            lines.append(f"SIGNATURE STATUS: BLOCKED -- {self.signature_blocked_reason}")
        elif self.signature_ready:
            lines.append("")
            lines.append("SIGNATURE STATUS: READY -- Subject to human approval.")
        lines.append("=" * 70)
        return "\n".join(lines)


# ---------------------------------------------------------------------------
# Generator
# ---------------------------------------------------------------------------

class LegalOpinionGenerator:
    """
    Generates structured legal opinions for institutional transactions.
    """

    def __init__(self) -> None:
        self.validator = ComplianceValidator()
        self.red_flag_detector = RedFlagDetector()
        self.conflict_matrix = ConflictMatrix()
        self.evidence_validator = EvidenceValidator()

    def generate(
        self,
        entity: dict[str, Any],
        counterparty: dict[str, Any],
        transaction_type: str,
    ) -> LegalOpinion:
        """Generate a complete legal opinion."""
        tx_def = load_transaction_type(transaction_type)
        now = datetime.now().isoformat(timespec="seconds")

        opinion = LegalOpinion(
            entity_name=entity.get("legal_name", "UNKNOWN"),
            counterparty_name=counterparty.get("legal_name", "UNKNOWN"),
            transaction_type=tx_def.get("display_name", transaction_type),
            generated_at=now,
        )

        # Run all analyses
        val_a = self.validator.validate_entity(entity, transaction_type, counterparty)
        val_b = self.validator.validate_entity(counterparty, transaction_type, entity)
        rf = self.red_flag_detector.scan(entity, counterparty, transaction_type)

        jur_a = entity.get("jurisdiction", "").split("-")[0].upper()
        jur_b = counterparty.get("jurisdiction", "").split("-")[0].upper()
        is_cross_border = jur_a != jur_b

        # Build sections
        opinion.sections.append(
            self._regulatory_exposure(entity, counterparty, val_a, val_b, rf)
        )
        opinion.sections.append(
            self._authority_opinion(entity, counterparty, val_a, val_b)
        )
        opinion.sections.append(
            self._enforceability_summary(entity, counterparty, jur_a, jur_b, is_cross_border)
        )
        opinion.sections.append(
            self._jurisdiction_conflict_analysis(entity, counterparty, jur_a, jur_b, tx_def)
        )
        opinion.sections.append(
            self._escrow_recommendation(entity, counterparty, is_cross_border, tx_def)
        )

        # Evidence assessment
        ev_a = self.evidence_validator.validate_entity_evidence(entity, counterparty)
        ev_b = self.evidence_validator.validate_entity_evidence(counterparty, entity)
        opinion.sections.append(
            self._evidence_assessment(ev_a, ev_b)
        )

        # Calculate overall grade
        opinion.overall_grade = self._calculate_overall_grade(opinion.sections)

        # Policy-driven signature readiness
        policy = PolicyEngine()
        if opinion.overall_grade == "ADVERSE" and policy.adverse_blocks_signature():
            opinion.signature_ready = False
            opinion.signature_blocked_reason = (
                "Policy prohibits signature when opinion grade is ADVERSE."
            )
        elif opinion.overall_grade == "UNABLE_TO_OPINE":
            unable_blocks = policy.opinion.get("unable_to_opine_blocks_signature", True)
            if unable_blocks:
                opinion.signature_ready = False
                opinion.signature_blocked_reason = (
                    "Policy prohibits signature when opinion grade is UNABLE_TO_OPINE."
                )
            else:
                opinion.signature_ready = True
        elif opinion.overall_grade in ("ADVERSE",):
            opinion.signature_ready = False
        else:
            opinion.signature_ready = True

        return opinion

    # --- Section A: Regulatory Exposure ---

    def _regulatory_exposure(
        self, entity: dict, counterparty: dict,
        val_a, val_b, rf,
    ) -> OpinionSection:
        section = OpinionSection(
            title="REGULATORY EXPOSURE SUMMARY",
            grade="CLEAR",
        )

        # Entity regulatory analysis
        rs_a = entity.get("regulatory_status", {})
        rs_b = counterparty.get("regulatory_status", {})
        lics_a = entity.get("licenses", [])
        lics_b = counterparty.get("licenses", [])

        # Identify regulated activities
        regulated_flags = [
            ("is_bank", "Banking"),
            ("is_broker_dealer", "Broker-Dealer"),
            ("is_ria", "Registered Investment Adviser"),
            ("is_fund", "Fund"),
            ("is_insurance_company", "Insurance"),
            ("is_money_services_business", "Money Services Business"),
            ("is_msp", "Major Swap Participant"),
            ("is_swap_dealer", "Swap Dealer"),
        ]

        for flag, label in regulated_flags:
            if rs_a.get(flag):
                section.body.append(f"Party A ({entity.get('legal_name')}): {label} — ACTIVE")
            if rs_b.get(flag):
                section.body.append(f"Party B ({counterparty.get('legal_name')}): {label} — ACTIVE")

        if not any(rs_a.get(f) for f, _ in regulated_flags):
            section.body.append(f"Party A ({entity.get('legal_name')}): No regulated status claimed.")
        if not any(rs_b.get(f) for f, _ in regulated_flags):
            section.body.append(f"Party B ({counterparty.get('legal_name')}): No regulated status claimed.")

        # License coverage
        section.body.append("")
        section.body.append(f"Party A licenses on file: {len(lics_a)}")
        section.body.append(f"Party B licenses on file: {len(lics_b)}")

        # Red flags affect grade
        if rf.critical_count > 0:
            section.grade = "ADVERSE"
            section.conditions.append(
                f"{rf.critical_count} CRITICAL red flag(s) detected. "
                f"Transaction should not proceed without resolution."
            )
        elif rf.high_count > 0:
            section.grade = "QUALIFIED"
            section.conditions.append(
                f"{rf.high_count} HIGH-severity flag(s) detected. "
                f"Enhanced due diligence required."
            )

        # Validation errors affect grade
        if val_a.errors or val_b.errors:
            section.grade = "ADVERSE" if section.grade != "ADVERSE" else section.grade
            section.conditions.append(
                f"Compliance validation errors: "
                f"Party A = {len(val_a.errors)}, Party B = {len(val_b.errors)}."
            )

        return section

    # --- Section B: Authority Opinion ---

    def _authority_opinion(
        self, entity: dict, counterparty: dict, val_a, val_b,
    ) -> OpinionSection:
        section = OpinionSection(
            title="AUTHORITY OPINION",
            grade="CLEAR",
        )

        for label, party, val in [
            ("Party A", entity, val_a),
            ("Party B", counterparty, val_b),
        ]:
            name = party.get("legal_name", label)
            signatories = party.get("signatories", [])
            binding = [s for s in signatories if s.get("can_bind_company")]
            directors = party.get("directors", [])
            full_auth_dirs = [d for d in directors if d.get("authority_scope") == "full"]

            section.body.append(f"{label} ({name}):")
            section.body.append(f"  Signatories: {len(signatories)} "
                                f"(binding authority: {len(binding)})")
            section.body.append(f"  Directors: {len(directors)} "
                                f"(full authority: {len(full_auth_dirs)})")

            # Check authorization chain
            if not binding:
                section.grade = "ADVERSE"
                section.conditions.append(
                    f"{name}: No signatory authorized to bind. "
                    f"Transaction cannot close."
                )
            else:
                for sig in binding:
                    if not sig.get("authorization_document"):
                        if section.grade == "CLEAR":
                            section.grade = "QUALIFIED"
                        section.conditions.append(
                            f"{name}: Signatory '{sig.get('name')}' has binding authority "
                            f"but no authorization document (board resolution / POA) on file."
                        )

            # Dual signature check
            if len(binding) == 1 and len(signatories) == 1:
                section.body.append(f"  [!] Single signatory -- no dual authorization.")
                if section.grade == "CLEAR":
                    section.grade = "QUALIFIED"
                section.conditions.append(
                    f"{name}: Consider requiring co-signatory for "
                    f"institutional transactions."
                )

            section.body.append("")

        return section

    # --- Section C: Enforceability Summary ---

    def _enforceability_summary(
        self, entity: dict, counterparty: dict,
        jur_a: str, jur_b: str, is_cross_border: bool,
    ) -> OpinionSection:
        section = OpinionSection(
            title="ENFORCEABILITY SUMMARY",
            grade="CLEAR",
        )

        section.body.append(f"Party A jurisdiction: {jur_a} ({get_jurisdiction_full_name(jur_a)})")
        section.body.append(f"Party B jurisdiction: {jur_b} ({get_jurisdiction_full_name(jur_b)})")
        section.body.append(f"Cross-border: {'YES' if is_cross_border else 'NO'}")

        # Load jurisdiction rules for enforceability analysis
        for jur_code in sorted(set([jur_a, jur_b])):
            try:
                rules = load_jurisdiction_rules(jur_code)
                gov = rules.get("governing_law", {})
                disp = rules.get("dispute_resolution", {})

                section.body.append(f"")
                section.body.append(f"{jur_code} Enforcement Framework:")
                section.body.append(f"  Default governing law: {gov.get('default', 'N/A')}")
                section.body.append(f"  Courts: {gov.get('courts', 'N/A')}")
                section.body.append(f"  Arbitration: {disp.get('arbitration_body', 'N/A')}")
                section.body.append(f"  Arbitration seat: {disp.get('arbitration_seat', 'N/A')}")

                # New York Convention check
                nyc = disp.get("new_york_convention_member")
                if nyc is not None:
                    section.body.append(
                        f"  New York Convention: {'YES ' + ICON_CHECK if nyc else 'NO ' + ICON_CROSS}"
                    )
                    if not nyc:
                        section.grade = "QUALIFIED"
                        section.conditions.append(
                            f"{jur_code} is NOT a New York Convention member. "
                            f"Foreign arbitral awards may not be enforceable."
                        )
            except ValueError:
                section.grade = "UNABLE_TO_OPINE"
                section.conditions.append(
                    f"Unable to load rules for jurisdiction {jur_code}."
                )

        # Cross-border enforceability concerns
        if is_cross_border:
            section.body.append("")
            section.body.append("Cross-Border Enforceability Considerations:")
            section.body.append("  • Judgment recognition between jurisdictions")
            section.body.append("  • Choice-of-law clause validity")
            section.body.append("  • Service of process requirements")
            section.body.append("  • Sovereign immunity considerations")

            if section.grade == "CLEAR":
                section.grade = "QUALIFIED"
            section.conditions.append(
                "Cross-border enforceability requires local counsel confirmation "
                "in each jurisdiction."
            )

        return section

    # --- Section D: Jurisdiction Conflict Analysis ---

    def _jurisdiction_conflict_analysis(
        self, entity: dict, counterparty: dict,
        jur_a: str, jur_b: str, tx_def: dict,
    ) -> OpinionSection:
        section = OpinionSection(
            title="JURISDICTION CONFLICT ANALYSIS",
            grade="CLEAR",
        )

        if jur_a == jur_b:
            section.body.append("Single-jurisdiction transaction. No conflicts detected.")
            return section

        # Run conflict matrix
        conflicts = self.conflict_matrix.analyze(
            jur_a, jur_b,
            transaction_type=tx_def.get("category", ""),
            entity_a=entity,
            entity_b=counterparty,
        )

        if not conflicts.conflicts:
            section.body.append("No jurisdiction conflicts detected.")
            return section

        for conflict in conflicts.conflicts:
            section.body.append(f"[{conflict.severity}] {conflict.category}:")
            section.body.append(f"  {conflict.description}")
            section.body.append(f"  → {conflict.recommendation}")
            section.body.append("")

            if conflict.severity == "CRITICAL":
                section.grade = "ADVERSE"
            elif conflict.severity == "HIGH" and section.grade not in ("ADVERSE",):
                section.grade = "QUALIFIED"
            elif conflict.severity == "MEDIUM" and section.grade == "CLEAR":
                section.grade = "QUALIFIED"

            section.conditions.append(conflict.recommendation)

        return section

    # --- Section E: Escrow Recommendation ---

    def _escrow_recommendation(
        self, entity: dict, counterparty: dict,
        is_cross_border: bool, tx_def: dict,
    ) -> OpinionSection:
        section = OpinionSection(
            title="ESCROW STRUCTURE RECOMMENDATION",
            grade="CLEAR",
        )

        banking_a = entity.get("banking", {})
        banking_b = counterparty.get("banking", {})
        escrow_required = (
            banking_a.get("escrow_required")
            or banking_b.get("escrow_required")
        )
        escrow_agent_a = banking_a.get("escrow_agent")
        escrow_agent_b = banking_b.get("escrow_agent")

        category = tx_def.get("category", "").lower()

        # Determine if escrow should be required
        needs_escrow = False
        reasons = []

        if is_cross_border:
            needs_escrow = True
            reasons.append("Cross-border transaction requires escrow for fund settlement.")

        if "securities" in category or "subscription" in category:
            needs_escrow = True
            reasons.append("Securities transaction — escrow required for closing mechanics.")

        if escrow_required:
            needs_escrow = True
            reasons.append("Entity banking data flags escrow_required = true.")

        if needs_escrow:
            section.body.append("ESCROW REQUIRED: YES")
            section.body.append("")
            section.body.append("Reasons:")
            for r in reasons:
                section.body.append(f"  • {r}")
            section.body.append("")

            # Check if escrow agent is defined
            if escrow_agent_a or escrow_agent_b:
                agent = escrow_agent_a or escrow_agent_b
                section.body.append(f"Escrow Agent: {agent}")
                section.body.append("")
                section.body.append("Recommended Escrow Structure:")
                section.body.append("  1. Independent third-party escrow agent")
                section.body.append("  2. Dual-key release mechanism")
                section.body.append("  3. Conditions precedent satisfaction trigger")
                section.body.append("  4. Dispute resolution via arbitration clause")
                section.body.append("  5. Escrow fees allocated per agreement")
            else:
                section.grade = "QUALIFIED"
                section.body.append("[!] NO ESCROW AGENT DEFINED")
                section.conditions.append(
                    "Escrow is required but no escrow agent has been identified. "
                    "Appoint a qualified escrow agent before document generation."
                )

            # Recommend custodian
            custodian_a = banking_a.get("custodian")
            custodian_b = banking_b.get("custodian")
            if custodian_a or custodian_b:
                section.body.append("")
                section.body.append("Available Custodians for Escrow:")
                if custodian_a:
                    section.body.append(
                        f"  Party A: {custodian_a} "
                        f"({banking_a.get('settlement_bank', 'N/A')})"
                    )
                if custodian_b:
                    section.body.append(
                        f"  Party B: {custodian_b} "
                        f"({banking_b.get('settlement_bank', 'N/A')})"
                    )
        else:
            section.body.append("ESCROW REQUIRED: NO")
            section.body.append("Single-jurisdiction, non-securities transaction.")
            section.body.append("Standard settlement procedures apply.")

        return section

    # --- Section F: Evidence Assessment ---

    def _evidence_assessment(self, ev_a, ev_b) -> OpinionSection:
        section = OpinionSection(
            title="EVIDENCE ASSESSMENT",
            grade="CLEAR",
        )

        for label, ev in [("Party A", ev_a), ("Party B", ev_b)]:
            section.body.append(f"{label} ({ev.entity_name}):")
            section.body.append(f"  Evidence directory: data/evidence/{ev.entity_slug}/")
            section.body.append(f"  Files on record: {ev.files_hashed}")
            section.body.append(f"  Gaps: {len(ev.gaps)}")
            section.body.append("")

            if ev.has_critical_gaps:
                if section.grade != "ADVERSE":
                    section.grade = "ADVERSE"
                for gap in ev.gaps:
                    if gap.severity == "ERROR":
                        section.conditions.append(f"{label}: {gap.description}")
            elif ev.gaps:
                if section.grade == "CLEAR":
                    section.grade = "QUALIFIED"
                for gap in ev.gaps:
                    section.conditions.append(f"{label}: {gap.description}")

        return section

    # --- Grade Calculation ---

    @staticmethod
    def _calculate_overall_grade(sections: list[OpinionSection]) -> str:
        grades = [s.grade for s in sections]

        if "ADVERSE" in grades:
            return "ADVERSE"
        if "UNABLE_TO_OPINE" in grades:
            return "UNABLE_TO_OPINE"
        if "QUALIFIED" in grades:
            return "QUALIFIED"
        return "CLEAR"
